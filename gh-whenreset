#!/usr/bin/env python3

import argparse
import json
import subprocess
import sys
from datetime import datetime
from zoneinfo import ZoneInfo, ZoneInfoNotFoundError


EXIT_NO_MATCH = 2


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="gh-whenreset",
        description="Print local reset timestamps from gh api /rate_limit JSON input.",
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Consider all buckets instead of only not-full (remaining < limit) buckets.",
    )
    parser.add_argument(
        "--tz",
        metavar="IANA_NAME",
        help="IANA timezone name (e.g. America/New_York). Defaults to system local timezone.",
    )
    return parser


def resolve_timezone(tz_name: str | None):
    if tz_name is None:
        return datetime.now().astimezone().tzinfo

    try:
        return ZoneInfo(tz_name)
    except ZoneInfoNotFoundError:
        print(f"Invalid timezone: {tz_name}", file=sys.stderr)
        sys.exit(EXIT_NO_MATCH)


def load_input() -> dict:
    try:
        data = json.load(sys.stdin)
    except json.JSONDecodeError as exc:
        print(f"Failed to parse JSON from stdin: {exc}", file=sys.stderr)
        sys.exit(EXIT_NO_MATCH)

    if not isinstance(data, dict):
        print("Input JSON must be an object.", file=sys.stderr)
        sys.exit(EXIT_NO_MATCH)
    return data


def load_from_gh_api() -> dict:
    try:
        result = subprocess.run(
            ["gh", "api", "/rate_limit"],
            check=False,
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print("Could not execute 'gh'. Ensure GitHub CLI is installed and on PATH.", file=sys.stderr)
        sys.exit(1)

    if result.returncode != 0:
        err = result.stderr.strip() or "gh api /rate_limit failed."
        print(err, file=sys.stderr)
        sys.exit(result.returncode or 1)

    try:
        data = json.loads(result.stdout)
    except json.JSONDecodeError as exc:
        print(f"Failed to parse JSON from gh api /rate_limit output: {exc}", file=sys.stderr)
        sys.exit(1)

    if not isinstance(data, dict):
        print("gh api /rate_limit returned non-object JSON.", file=sys.stderr)
        sys.exit(1)
    return data


def load_payload() -> dict:
    if sys.stdin.isatty():
        return load_from_gh_api()
    return load_input()


def considered_buckets(resources: dict, include_all: bool):
    for name, bucket in resources.items():
        if not isinstance(bucket, dict):
            continue

        remaining = bucket.get("remaining")
        reset = bucket.get("reset")
        if not isinstance(remaining, int) or not isinstance(reset, int):
            continue

        limit = bucket.get("limit")
        if include_all:
            yield name, remaining, limit, reset
            continue

        if isinstance(limit, int) and remaining < limit:
            yield name, remaining, limit, reset


def format_relative(seconds_from_now: int) -> str:
    absolute = abs(seconds_from_now)
    if absolute < 60:
        value = absolute
        unit = "s"
    elif absolute < 3600:
        value = absolute // 60
        unit = "min"
    elif absolute < 86400:
        value = absolute // 3600
        unit = "h"
    else:
        value = absolute // 86400
        unit = "d"

    if seconds_from_now >= 0:
        return f"in {value}{unit}"
    return f"{value}{unit} ago"


def format_percentage_remaining(remaining: int, limit: int | None) -> str | None:
    if not isinstance(limit, int) or limit <= 0 or remaining <= 0:
        return None

    percent = (remaining / limit) * 100
    if percent.is_integer():
        return f"{int(percent)}%"
    return f"{percent:.1f}%"


def format_local_display_time(local_dt: datetime, now_local_dt: datetime) -> str:
    day_delta = (local_dt.date() - now_local_dt.date()).days
    if day_delta >= 1:
        return local_dt.strftime("%Y-%m-%d %H:%M")
    return local_dt.strftime("%H:%M")


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()

    tz = resolve_timezone(args.tz)
    payload = load_payload()

    resources = payload.get("resources")
    if not isinstance(resources, dict):
        print("Input JSON is missing object field: resources", file=sys.stderr)
        return EXIT_NO_MATCH

    matches = sorted(considered_buckets(resources, include_all=args.all), key=lambda item: item[3])
    if not matches:
        criterion = "all buckets" if args.all else "not-full buckets (remaining < limit)"
        print(f"No rate limit buckets matched: {criterion}.", file=sys.stderr)
        return EXIT_NO_MATCH

    bucket_width = max(len(bucket_name) for bucket_name, _remaining, _limit, _reset in matches)
    now_local_dt = datetime.now(tz=tz)
    now_epoch = int(now_local_dt.timestamp())
    for bucket_name, remaining, limit, reset in matches:
        local_dt = datetime.fromtimestamp(reset, tz=tz)
        display_time = format_local_display_time(local_dt, now_local_dt)
        relative = format_relative(reset - now_epoch)
        percent = format_percentage_remaining(remaining, limit)
        if percent is not None:
            relative = f"{relative} ({percent} remaining)"
        print(f"{display_time}  {bucket_name:<{bucket_width}}  {relative}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
